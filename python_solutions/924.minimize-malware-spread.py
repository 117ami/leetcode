from collections import Counter, defaultdict, OrderedDict, deque
from bisect import bisect_left, bisect_right
from functools import reduce, lru_cache
from typing import List
import itertools
import math
import heapq
import string
true = True
false = False
MIN, MAX, MOD = -0x3f3f3f3f, 0x3f3f3f3f, 1000000007


#
# @lc app=leetcode id=924 lang=python3
#
# [924] Minimize Malware Spread
#
# https://leetcode.com/problems/minimize-malware-spread/description/
#
# algorithms
# Hard (41.98%)
# Total Accepted:    24K
# Total Submissions: 57.2K
# Testcase Example:  '[[1,1,0],[1,1,0],[0,0,1]]\n[0,1]'
#
# In a network of nodes, each node i is directly connected to another node j if
# and only if graph[i][j] = 1.
#
# Some nodes initial are initially infected by malware.  Whenever two nodes are
# directly connected and at least one of those two nodes is infected by
# malware, both nodes will be infected by malware.  This spread of malware will
# continue until no more nodes can be infected in this manner.
#
# Suppose M(initial) is the final number of nodes infected with malware in the
# entire network, after the spread of malware stops.
#
# We will remove one node from the initial list.  Return the node that if
# removed, would minimize M(initial).  If multiple nodes could be removed to
# minimize M(initial), return such a node with the smallest index.
#
# Note that if a node was removed from the initial list of infected nodes, it
# may still be infected later as a result of the malware spread.
#
#
#
#
#
#
# Example 1:
#
#
# Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
# Output: 0
#
#
# Example 2:
#
#
# Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
# Output: 0
#
#
# Example 3:
#
#
# Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
# Output: 1
#
#
#
#
# Note:
#
#
# 1 < graph.length = graph[0].length <= 300
# 0 <= graph[i][j] == graph[j][i] <= 1
# graph[i][i] == 1
# 1 <= initial.length <= graph.length
# 0 <= initial[i] < graph.length
#
#
#
class UF:
    def __init__(self, n):
        self.p = list(range(n))

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        self.p[px] = self.p[py] = min(px, py)

    def find(self, x):
        if x != self.p[x]:
            self.p[x] = self.find(self.p[x])
        return self.p[x]


class Solution:
    def minMalwareSpread(self, graph: List[List[int]],
                         initial: List[int]) -> int:
        n = len(graph)
        uf = UF(n)

        # print(res)
        for i, j in itertools.product(range(n), range(n)):
            if graph[i][j] == 1:
                # print(i,j)
                uf.union(i, j)
        cc = defaultdict(set)
        for i in range(len(graph)):
            f = uf.p[i]
            cc[f].add(i)
        initial = set(initial)

        print(uf.p, cc)
        savor, max_size = -1, 0
        sss = sorted(filter(lambda v: 1 == len(v.intersection(initial)),
                            cc.values()),
                     key=lambda v: (len(v), -min(v)))
        if sss: return min(sss[-1].intersection(initial))
        # for k, v in cc.items():
        # 	inter = v.intersection(initial)
        # 	if len(inter) == 1:
        # 		if max_size < len(v):
        # 			max_size = len(v)
        # 			savor = min(inter)

        # if savor > -1:
        # 	return savor
        return min(initial)


sol = Solution()
graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]
initial = [0, 1]
graph = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
initial = [0, 2]
graph, initial = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1,
                                                             1]], [3, 1]
# graph = [[1,1,1],[1,1,1],[1,1,1]]; initial = [1,2]
print(sol.minMalwareSpread(graph, initial))
