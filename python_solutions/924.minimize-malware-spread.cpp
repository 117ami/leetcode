/*
 * @lc app=leetcode id=924 lang=cpp
 *
 * [924] Minimize Malware Spread
 *
 * https://leetcode.com/problems/minimize-malware-spread/description/
 *
 * algorithms
 * Hard (41.98%)
 * Total Accepted:    24K
 * Total Submissions: 57.2K
 * Testcase Example:  '[[1,1,0],[1,1,0],[0,0,1]]\n[0,1]'
 *
 * In a network of nodes, each node i is directly connected to another node j
 * if and only if graph[i][j] = 1.
 *
 * Some nodes initial are initially infected by malware.  Whenever two nodes
 * are directly connected and at least one of those two nodes is infected by
 * malware, both nodes will be infected by malware.  This spread of malware
 * will continue until no more nodes can be infected in this manner.
 *
 * Suppose M(initial) is the final number of nodes infected with malware in the
 * entire network, after the spread of malware stops.
 *
 * We will remove one node from the initial list.  Return the node that if
 * removed, would minimize M(initial).  If multiple nodes could be removed to
 * minimize M(initial), return such a node with the smallest index.
 *
 * Note that if a node was removed from the initial list of infected nodes, it
 * may still be infected later as a result of the malware spread.
 *
 *
 *
 *
 *
 *
 * Example 1:
 *
 *
 * Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
 * Output: 0
 *
 *
 * Example 2:
 *
 *
 * Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
 * Output: 0
 *
 *
 * Example 3:
 *
 *
 * Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
 * Output: 1
 *
 *
 *
 *
 * Note:
 *
 *
 * 1 < graph.length = graph[0].length <= 300
 * 0 <= graph[i][j] == graph[j][i] <= 1
 * graph[i][i] == 1
 * 1 <= initial.length <= graph.length
 * 0 <= initial[i] < graph.length
 *
 *
 */
class UF {
public:
  vector<int> parent;
  vector<int> rank;
  UF(int n) : parent(n), rank(n, 0) {
    for (int i = 0; i < n; ++i) {
      parent[i] = i;
    }
  }

  int find(int x) {
    if (x != parent[x]) {
      parent[x] = find(parent[x]);
    }
    return parent[x];
  }

  void unite(int x, int y) {
    // merge node x and y
    int fx = find(x);
    int fy = find(y);
    parent[fx]=parent[fy]= min(fx, fy);
    // if (rank[fx] > rank[fy]) {
    //   parent[fy] = fx;
    // } else if (rank[fx] == rank[fy]) {
    //   rank[fy] += 1;
    //   parent[fx] = fy;
    // } else {
    //   parent[fx] = fy;
    // }
  }
};

class Solution {
public:
  int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial) {
    int n = graph.size();
    UF uf(n);
    for (int i = 0; i < n; i++)
      for (int j = i + 1; j < n; j++)
        if (graph[i][j])
          uf.unite(i, j);
    for (int i = 0; i < n; i++)
      uf.find(i);
    // say(uf.parent);
    map<int, unordered_set<int>> cc;
    for (int i = 0; i < n; i++) {
      int p = uf.parent[i];
      cc[p].insert(i);
    }

    set<int> ini(initial.begin(), initial.end());
    int savor = -1, maxsize = 0;
    for (auto &[k, vset] : cc) {
      set<int> intersect;
      for (auto x : vset)
        if (ini.find(x) != ini.end())
          intersect.insert(x);
      //   std::set_intersection(vset.begin(), vset.end(), ini.begin(),
      //   ini.end(),
      //                         std::inserter(intersect, intersect.begin()));
      // say(k);say(intersect);say(vset);say(ini);say("----------");

      if (intersect.size() == 1) {
        if (maxsize < vset.size()) {
          // say(intersect);

          maxsize = vset.size();
          savor = *std::min_element(intersect.begin(), intersect.end());
        }
      }
      //   say(savor);
    }

    if (savor > -1)
      return savor;
    return *std::min_element(ini.begin(), ini.end());
  }
};


auto speedUp = [] () {
    ios_base::sync_with_stdio(false);
    return 0;
}();