from collections import Counter, defaultdict, OrderedDict, deque
from bisect import bisect_left, bisect_right
from functools import reduce, lru_cache
from typing import List
import itertools
import math
import heapq
import string
true = True
false = False
MIN, MAX, MOD = -0x3f3f3f3f, 0x3f3f3f3f, 1000000007

#
#@lc app = leetcode id = 928 lang = python3
#
#[928] Minimize Malware Spread II
#
#https: // leetcode.com/problems/minimize-malware-spread-ii/description/
#
#algorithms
#Hard(40.55 %)
#Total Accepted : 9.6K
#Total Submissions : 23.6K
#Testcase Example : '[[1,1,0],[1,1,0],[0,0,1]]\n[0,1]'
#
#(This problem is the same as Minimize Malware Spread, with the differences
#bolded.)
#
#In a network of nodes, each node i is directly connected to another node j if
#and only if  graph[i][j] = 1.
#
#Some nodes initial are initially infected by malware.  Whenever two nodes are
#directly connected and at least one of those two nodes is infected by
#malware, both nodes will be infected by malware.  This spread of malware will
#continue until no more nodes can be infected in this manner.
#
#Suppose M(initial) is the final number of nodes infected with malware in the
#entire network, after the spread of malware stops.
#
#We will remove one node from the initial list, completely removing it and any
#connections from this node to any other node.  Return the node that if
#removed, would minimize M(initial).  If multiple nodes could be removed to
#minimize M(initial), return such a node with the smallest index.
#
#
#
#
#
#
#
#Example 1:
#
#
#Input : graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]], initial = [0, 1]
#Output : 0
#
#
#
#Example 2:
#
#
#Input : graph = [[1, 1, 0], [1, 1, 1], [0, 1, 1]], initial = [0, 1]
#Output : 1
#
#
#
#Example 3:
#
#
#Input : graph = [[1, 1, 0, 0],                                                \
                   [1, 1, 1, 0], [0, 1, 1, 1], [0, 0, 1, 1]], initial = [0, 1]
#Output : 1
#
#
#
#
#Note:
#
#
# 1 <graph.length = graph[0].length <= 300
# 0 <= graph[i][j] == graph[j][i] <= 1
#graph[i][i] = 1
# 1 <= initial.length <graph.length
# 0 <= initial[i] <graph.length
#
#
#
#
#
class Solution:
    def minMalwareSpread(self, graph: List[List[int]],
                         initial: List[int]) -> int:
        self.size = len(graph)
        neighbors = defaultdict(set)
        for i in range(self.size):
            for j in range(i + 1, self.size):
                if graph[i][j]:
                    neighbors[i].add(j)
                    neighbors[j].add(i)

        def solve(n):
#remove node n, and check how many nodes will be left
#uninfected
            dead, copy = set(initial), set()
            dead.remove(n)
            while copy != dead:
                copy = dead.copy()
                dead.update(set.union(*map(lambda d: neighbors[d], copy)))
                if n in dead: dead.remove(n)
            return self.size - len(dead)

        return sorted(map(lambda i: (i, solve(i)), sorted(initial)),
                      key=lambda p: (p[1], -p[0]))[-1][0]


sol = Solution()
g, i = [[1, 1, 0], [1, 1, 0], [0, 0, 1]], [0, 1]
g, i = [[1, 1, 1, 0], [1, 1, 0, 0], [1, 0, 1, 0], [0, 0, 0, 1]], [3, 2]
#graph = [[1, 1, 0], [1, 1, 1], [0, 1, 1]], initial = [0, 1]
g, i = [[1, 1, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [0, 0, 1, 1]], [0, 1]
print(sol.minMalwareSpread(g, i))
